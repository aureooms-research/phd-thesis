\section{Algorithms}

In general, when we think of algorithms 



To make clear what will be considered an algorithm in this thesis, we explain
the different computation model that will be

\subsection{RAM Alorithms}

Real-RAM vs Word-RAM

\subsection{Nonuniform Algorithms}

%\improve{In general, I think there can hardly be too many warnings and remarks on the
%notion of nonuniformity. I expect reviewers to ask questions on, and
%misunderstand, everything nonuniform. Maybe it would be worth having an whole
%paragraph on this in the introduction, pointing to where nonuniformity is
%exploited.}

%One of the original motivations behind solving this problem efficiently is that
%the KNAPSACK and SUBSET-SUM problems reduce to it. The main motivation in this
%paper focuses on k-SUM, the parameterized version of SUBSET-SUM.

%Solving the point location problem amounts to compute the sign of the dot
%product of the input point with the coefficient vector of each hyperplane and
%can be solved in $O(dn)$ arithmetic operations by bruteforce.

%The linear decision tree model does not allow to compute the dot product of the
%input point with a fixed vector, nor does it count arithmetic operations. In
%this model, an algorithm is not given direct access to the input. Instead, an
%algorithm is allowed to ask an oracle low complexity queries about the input.
%Based on the answers to those queries, an algorithm is allowed to make use of
%unlimited computation power, at no cost, to deduce the answer to the original
%problem. If not enough information is available to answer the problem, the
%algorithm will use its costless computation power to decide which questions to
%ask next. In the linear decision tree model, the low complexity queries output
%the sign of a linear combination of the input point's coordinates. The cost of
%an algorithm in this model is the number of queries this algorithm asks to
%solve a problem.


Allow a different algorithm for each input size.
Compare to circuits: time to construct circuit does not count.

\paragraph{Computation Trees and Decision Trees}
We consider \emph{algebraic computation trees}, whose internal nodes
are labeled with arithmetic (\(r \gets o_1 \op o_2, \op \in
\{\,+,-,\times,\div\,\}\)) and branching (\(z : 0\)) operations. We say that an
algebraic computation tree $T$ \emph{realizes} an algorithm $A$ if the paths
from the root to the leaves of $T$ correspond to the execution paths of \(A\)
on all possible inputs \(q \in \mathbb{R}^n\), where \(n\) is fixed. A leaf is
labeled with the output of the corresponding execution path of \(A\). Such a
tree is \emph{well-defined} if any internal node labeled \(r \gets o_1 \op
o_2\) has outdegree \(1\) and is such that either \(o_k = q_i\) for some \(i\)
or there exists an ancestor \(o_k \gets x \op y\) of this node, and any
internal node labeled \(z : 0\) has outdegree \(3\) and is such that either \(z
= q_i\) for some \(i\) or there exists an ancestor \(z \gets x \op y\) of this
node. In the algebraic computation tree model, we define the complexity
\(f(n)\) of an algorithm $A$ to be the minimum depth of a well-defined
computation tree that realizes $A$ for inputs of size $n$.

In the algebraic computation tree model, we only count the operations that
involve the input, that is, members of the input or results of previous
operations involving the input.

Algebraic Computation Trees,
Decision Trees,
Algebraic Decision Trees,
Linear Decision Trees.

\paragraph{Linear Decision Trees}

The \emph{\(s\)-linear decision tree model} is a standard model of computation
in which several lower bounds for \(k\)-SUM\ have been proven. In the decision tree
model, one may ask well-defined questions to an oracle that are answered
``yes'' or ``no.'' For $s$-linear decision trees, a well-defined question consists
of testing the sign of a linear function on at most \(s\) numbers \(q_{i_1},\ldots,q_{i_s}\) of the
input \(q_1,\ldots,q_n\) and can be written as
%
\begin{displaymath}
	\alpha_1 q_{i_1} + \cdots + \alpha_s q_{i_s} \ask{\le} \alpha_0
\end{displaymath}
%
Each question is defined to cost a single unit. All other operations can be
carried out for free but may not examine the input vector $q$. We refer to
$n$-linear decision trees simply as linear decision trees.

\paragraph{Models of Computation}

Similarly to Gr\o nlund and Pettie~\cite{GP18}, we consider both nonuniform
and uniform models of computation.
%
For the nonuniform model, Gr\o nlund and Pettie consider linear
decision trees, where one is only allowed to manipulate the input numbers
through linear queries to an oracle. Each linear query has constant cost and
all other operations are free but cannot inspect the input.
%
In this paper, we consider
\emph{bounded-degree algebraic decision trees (ADT)}~\cite{R72,Y81,SY82},
an algebraic generalization of linear decision trees,
as the nonuniform model. In a bounded-degree algebraic decision tree, one
performs constant cost branching operations that amount to test the sign of
a constant-degree polynomial of the input numbers. Again,
operations not involving the input are free.
%
For the uniform model we consider the real-RAM model with only the four
arithmetic operators.
