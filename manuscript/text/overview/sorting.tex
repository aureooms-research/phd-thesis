Before continuing, let us go back to the origins of those different problems.
The link between them will be made even clearer.

Sorting is one of the oldest and most relevant data management problems.
It is the archetypal computation tree problem.
%
Usually presented, sorting is about permutations in \emph{arrays}, but we do
not like that. We use a different abstraction:
%
\input{text/definition/sorting}

In other words, we see the sorting problem as an information retrieval problem:
how many comparisons do we need to make in order to \emph{know} the answer to
all comparisons.
%
The usual sorting algorithms rearrange an array of input numbers into sorted
order. Another way to think about it is that they compute the permutation that
sends the input array to a sorted version of itself. This permutation is a data
structure such that given any index in the input array, we can query for the
corresponding index in the sorted array called the \emph{rank} of the element).
To retrieve the result of a comparison of two elements of the input array we can
compare their ranks in this permutation.
The usual way of defining the sorting problem restricts the data structure that
should be used to encode the \(n \choose 2\) comparisons.
The way we model the sorting problem lifts this restriction because it does not
ask to structure this information in a nice way.

The sorting problem also has its decision problem variant: Element Uniqueness.
%
\input{text/definition/element-uniqueness}

It is easy to see
that Sorting amounts to locating the point \(q\) in
the arrangement of hyperplanes of equations \(x_i - x_j = 0\)%
, and
that Element Uniqueness reduces both to and from the 2SUM
problem in linear time%
.
%
Actually, under reasonable assumptions on the computation model, sorting and
element uniqueness are the same problems: if all questions we ask about the
input are linear in the input numbers, then proving that the input
does not contain any duplicate entries requires to sort the input.
%
The same statement carries over to the \(k\)-SUM with respect to its ``sorting
version'': computing the sign of all \(n \choose k\) sums of \(k\) input
numbers.
%
Therefore, in those models of computation, the sorting problem is equivalent to
2SUM.
%
Because of this relationship between Sorting and the \(k\)-SUM problem,
we see why the better understanding of \(k\)-SUM is a natural next move.

Among all the problems this thesis touches, Sorting and Element Uniqueness
are the best understood. We know \(\Omega(n \log n)\) lower bounds in many
nonuniform models of computation and we also know a long list of simple
real-RAM algorithms for those problems whose running times match those lower
bounds. For all that matters here, those problems are solved.
