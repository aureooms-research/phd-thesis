\chapter{Encoding 3SUM}
\label{paper:3sum-encoding}

Given three sets of \(N\) real numbers
\(A = \{\, a_1 < a_2 < \cdots < a_N\,\} \),
\(B = \{\, b_1 < b_2 < \cdots < b_N\,\} \),
and \(C = \{\, c_1 < c_2 < \cdots < c_N\,\}\),
we wish to build a discrete data structure (using bits, words, and pointers) such that,
given any triple \((i,j,k) \in {[N]}^3\) it is possible to compute the sign of
\(a_i + b_j + c_k\) by only inspecting the data structure (we cannot consult
\(A\), \(B\), or \(C\)).
We refer to the map $\chi : {[N]}^3\to \{-,0,+\}, (i,j,k)\mapsto\mathrm{sgn}
(a_i+b_i+c_k)$ as the {\em 3SUM type} of the instance $\langle A,B,C \rangle$.

Obviously, one can simply construct a lookup table of size \(O(N^3)\), such
that triple queries can be answered in \(O(1)\) time.
%
In \S\ref{s:numbers} we show that a minimal integer representation of a
3SUM instance may require $\Theta(n)$ bits per value, yielding
$O(n)$ query time and $O(n^2)$ space.
%
In \S\ref{s:space} we show how to use an optimal $O(n \log n)$ bits of
space with a polynomial query time. Finally, in section~\ref{s:sscqt} we show
how to use $\tilde{O}(n^{3/2})$ space to achieve $O(1)$-time queries.

\input{text/paper/3sum-encoding/02-contribution}
