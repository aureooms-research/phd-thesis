\chapter{\done Divide and Conquer}%
\label{chapter:divide-and-conquer}

A general divide-and-conquer paradigm in algorithm design is,
given an instance of size \(n\), to 1) divide it into at most
\(a\) smaller instances of size at most \(\frac{n}{b}\) in \(p(n)\)
preprocessing time, 2) solve those instances recursively,
solving constant size instances by brute force, and 3) postprocess the
solutions of those smaller instances to obtain the solution to the original
one in \(p(n)\) time.
%
An upper bound \(T(n)\) on the time complexity of such an algorithm is the
reccurence
\begin{displaymath}
	T(n) = a \,\, T\mleft(\frac nb\mright) + p(n).
\end{displaymath}
%
The asymptotic behavior of such a recurrence can then be derived from the
Master Theorem~\cite{BHS80,CLRS09}.

In this chapter we expose standard divide-an-conquer techniques in
Computational Geometry that allow the implementation of this paradigm (or
variants of it).
%
Papers~\ref{paper:ksum-algorithm},~\ref{paper:3pol-algorithm},
and~\ref{paper:order-type-encoding} explicitly rely on those techniques.
%
The subquadratic-space constant-querytime encoding in
Paper~\ref{paper:3sum-encoding} can also be interpreted as an ad-hoc
implementation of those concepts (see \S\ref{s:sscqt}).

\input{text/tool/epsilon-nets-and-cuttings}

\input{text/tool/hierarchical-cuttings}
